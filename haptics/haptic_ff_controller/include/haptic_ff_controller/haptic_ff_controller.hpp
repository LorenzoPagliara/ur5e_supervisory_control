/* -------------------------------------------------------------------
 *
 * This module has been developed by the Automatic Control Group
 * of the University of Salerno, Italy.
 *
 * Title:   haptic_ff_controller.hpp
 * Author:  Michele Marsico, Salvatore Paolino
 * Org.:    UNISA
 * Date:    Oct 2, 2024
 *
 * This module implements the HapticFeedforwardController class, a
 * controller that reads the pose of the haptic device, and generate a
 * task space pose reference.
 *
 * -------------------------------------------------------------------
 */

#ifndef HAPTIC_FF_CONTROLLER__HAPTIC_FF_CONTROLLER_HPP_
#define HAPTIC_FF_CONTROLLER__HAPTIC_FF_CONTROLLER_HPP_

// auto-generated by generate_parameter_library
#include <haptic_ff_controller/haptic_ff_controller_parameters.hpp>

#include <controller_interface/controller_interface.hpp>
#include <rclcpp/rclcpp.hpp>
#include <hardware_interface/types/hardware_interface_return_values.hpp>
#include <hardware_interface/types/hardware_interface_type_values.hpp>
#include <rclcpp_lifecycle/node_interfaces/lifecycle_node_interface.hpp>
#include <rclcpp_lifecycle/state.hpp>
#include <pluginlib/class_loader.hpp>
#include "acg_control_msgs/msg/task_space_trajectory_point.hpp"
#include <kinematics_interface/kinematics_interface.hpp>
#include <geometry_msgs/msg/pose.hpp>
#include <geometry_msgs/msg/pose_stamped.hpp>
#include <geometry_msgs/msg/twist.hpp>
#include <memory>
#include <filters/filter_base.hpp>
#include <Eigen/Geometry>
#include <tf2/LinearMath/Transform.h>
#include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>
#include <angles/angles.h>
#include <stdexcept>
#include <sstream>
#include "moving_average_poses_filter/moving_average_poses_filter.hpp"
#include <filters/filter_chain.hpp>
#include <tf2_kdl/tf2_kdl.hpp>
#include <visualization_msgs/msg/marker_array.hpp>
#include <visualization_msgs/msg/marker.hpp>
#include <realtime_tools/realtime_publisher.hpp>

//#include <moving_average_poses_filter/moving_average_poses_filter.hpp>
namespace haptic_ff_controller
{
typedef std::runtime_error Exception;
class HapticFeedforwardController : public controller_interface::ControllerInterface
{
public:
  /**
   * @brief Constructor for HapticFeedforwardController.
   */
  HapticFeedforwardController();

  /**
   * @brief Destructor for HapticFeedforwardController.
   */
  ~HapticFeedforwardController();

  /**
   * @brief Called by the controller manager when the controller is initialized.
   *
   * This method is not subject to the control loop time and cannot access state interfaces.
   *
   * @return CallbackReturn indicating success or failure.
   */
  controller_interface::CallbackReturn on_init() override;

  /**
   * @brief Provides the command interface configuration.
   *
   * Called by the controller manager to get the command interface configuration.
   *
   * @return InterfaceConfiguration for the command interface.
   */
  controller_interface::InterfaceConfiguration command_interface_configuration() const override;

  /**
   * @brief Provides the state interface configuration.
   *
   * Called by the controller manager to get the state interface configuration.
   *
   * @return InterfaceConfiguration for the state interface.
   */
  controller_interface::InterfaceConfiguration state_interface_configuration() const override;

  /**
   * @brief Updates the controller.
   *
   * Called by the controller manager to update the controller.
   *
   * @param time The current time.
   * @param period The time since the last update.
   * @return return_type indicating success or failure.
   */
  controller_interface::return_type update(const rclcpp::Time& time, const rclcpp::Duration& period) override;

  /**
   * @brief Called by the controller manager when the controller is configured.
   *
   * This method is not subject to the control loop time and cannot access state interfaces.
   *
   * @param previous_state The previous state of the lifecycle.
   * @return CallbackReturn indicating success or failure.
   */
  controller_interface::CallbackReturn on_configure(const rclcpp_lifecycle::State& previous_state) override;

  /**
   * @brief Called by the controller manager when the controller is activated.
   *
   * This method is subject to the control loop time and can read state interfaces.
   *
   * @param previous_state The previous state of the lifecycle.
   * @return CallbackReturn indicating success or failure.
   */
  controller_interface::CallbackReturn on_activate(const rclcpp_lifecycle::State& previous_state) override;

  /**
   * @brief Called by the controller manager when the controller is deactivated.
   *
   * @param previous_state The previous state of the lifecycle.
   * @return CallbackReturn indicating success or failure.
   */
  controller_interface::CallbackReturn on_deactivate(const rclcpp_lifecycle::State& previous_state) override;

protected:
  /**
   * @brief Compute the average of a set of poses.
   *
   * @param haptic_device_pose current haptic device pose to average
   *
   * @return the average pose of the haptic device
   */
  geometry_msgs::msg::Pose computeAveragePose_(geometry_msgs::msg::Pose& haptic_device_pose);

  /**
   * @brief Engage the robot with haptic control.
   */
  void engageRobot();

  /**
   * @brief Place the haptic end-effector frame at the tool tip.
   *
   * @param haptic_device_pose The current pose of the haptic device.
   * @param base_to_end_effector_transform The actual robot base to end-effector transformation
   *
   * @return the poses resulting from the merge between the haptic device orientation relative to the robot base link
   * and the tool tip and the end-effector position
   */
  void placeHapticEEFrameAtToolTip_(const geometry_msgs::msg::Pose& haptic_device_pose,
                                    const Eigen::Isometry3d& base_to_end_effector_transform) const;

  /**
   * @brief Set the actual robot and haptic devices transforms.
   *
   * @param[in] haptic_device_transform actual haptic device transform
   * @param[in] robot_ee_transform actual robot end-effector transform
   */
  void setRobotAndHapticDeviceEEPose_(const Eigen::Isometry3d& haptic_device_transform, const Eigen::Isometry3d& robot_ee_transform);

  /**
   * @brief Initialize the Transform object with RPY angles taken through param_name.
   *
   * @param[out] rotation_matrix rotation matrix to initialize
   * @param[in] param_name parameter's name on Parameter Server
   *
   * @throw ros::UnavailableParameterException if the parameter is not on the parameter server
   */
  void initRotationFromRPY_angles_(Eigen::Matrix3d& rotation_matrix, const std::vector<double>& RPY_angles) const;

  /**
   * @brief Reads the robot state from the state interfaces and stores it in a 3D state vector.
   * @return Eigen::VectorXd containing the robot joint state.
   */
  void read_robot_state_(Eigen::VectorXd& robot_joint_state) const;

  /**
   * @brief Convert the haptic device end-effector pose into the corresponding robot one.
   *
   * @param[in] haptic_device_pose haptic device pose
   * @param[in] haptic_device_stylus_angles haptic device stylus gimbal angles
   * @param[out] robot_pose robot pose corresponding to the haptic one
   *
   * @throw haptic_device::Exception if the initial position of the robot and haptic device was not set
   */
  void convertHapticEEPoseToRobotEEPose_(const geometry_msgs::msg::Pose& haptic_device_pose, geometry_msgs::msg::Pose& robot_pose);

  void convertHapticEEPoseToRobotEEPose2_(const geometry_msgs::msg::Pose& haptic_device_pose, const geometry_msgs::msg::Twist& haptic_device_twist,
                                          geometry_msgs::msg::Pose& robot_pose, geometry_msgs::msg::Twist& robot_twist,
                                          const rclcpp::Duration& period);

  void publishRobotPoseMarker(const geometry_msgs::msg::Pose& robot_pose);

  /**
   * @brief Convert the haptic device end-effector pose orientation into the corresponding robot orientation.
   *
   * @param[in] haptic_device_pose haptic device pose
   * @param[out] robot_orientation_pose robot orientation corresponding to the haptic one
   *
   * @throw haptic_device::Exception if the initial position of the robot and haptic device was not set
   */
  void convertHapticEEOrientationToRobotEEOrientation_(const geometry_msgs::msg::Pose& haptic_device_pose, Eigen::Matrix3d& robot_orientation_pose);

  /**
   * @brief Read the haptic device pose.
   */
  void read_haptic_state_();

  /**
   * @brief Wait for the haptic device pose topic to be ready.
   */
  void wait_read_topic_haptic_pose_();

  KDL::Frame transformToKDLFrame_(Eigen::Isometry3d transform);

  /**
   * @brief Parameters handler.
   */
  std::shared_ptr<haptic_ff_controller::ParamListener> parameter_handler_;

  /**
   * @brief Haptic pose read from topic in simulation.
   */
  geometry_msgs::msg::PoseStamped topic_haptic_pose_;

  /**
   * @brief Haptic twist read from topic in simulation.
   */
  geometry_msgs::msg::TwistStamped topic_haptic_twist_;

  /**
   * @brief Current haptic pose.
   */
  geometry_msgs::msg::Pose haptic_pose_;

  /**
   * @brief Current haptic twist.
   */
  geometry_msgs::msg::Twist haptic_twist_;

  /**
   * @brief Filtered haptic pose.
   */
  geometry_msgs::msg::Pose filtered_haptic_pose_;

  /**
   * @brief Publisher for logging task space references sent to the task space controller.
   */
  rclcpp::Publisher<geometry_msgs::msg::PoseStamped>::SharedPtr reference_pose_publisher_;

  std::unique_ptr<realtime_tools::RealtimePublisher<geometry_msgs::msg::PoseStamped>> realtime_reference_pose_publisher_;

  /**
   * @brief Publisher for logging twist references sent to the task space controller.
   */
  rclcpp::Publisher<geometry_msgs::msg::TwistStamped>::SharedPtr reference_twist_publisher_;

  std::unique_ptr<realtime_tools::RealtimePublisher<geometry_msgs::msg::TwistStamped>> realtime_reference_twist_publisher_;

  /**
   * @brief Subscriber for haptic device pose on the topic in simulation.
   */
  rclcpp::Subscription<geometry_msgs::msg::PoseStamped>::SharedPtr haptic_pose_subscriber_;

  /**
   * @brief Subscriber for haptic device twist on the topic in simulation.
   */
  rclcpp::Subscription<geometry_msgs::msg::TwistStamped>::SharedPtr haptic_twist_subscriber_;

  /**
   * @brief Publisher of haptic robot poses in RViz.
   */
  rclcpp::Publisher<geometry_msgs::msg::PoseStamped>::SharedPtr haptic_pose_rviz_publisher_;

  std::unique_ptr<realtime_tools::RealtimePublisher<geometry_msgs::msg::PoseStamped>> realtime_haptic_pose_rviz_publisher_;

  /**
   * @brief Kinematics interface.
   */
  std::unique_ptr<kinematics_interface::KinematicsInterface> kinematics_;

  /**
   * @brief Kinematics interface plugin loader.
   */
  std::shared_ptr<pluginlib::ClassLoader<kinematics_interface::KinematicsInterface>> kinematics_loader_;

  /**
   * @brief Engagement orientation threshold.
   */
  double engagement_orientation_threshold_;

  /**
   * @brief Robot joint state.
   */
  Eigen::VectorXd robot_joint_state_;

  /**
   * @brief Initial robot joint state.
   */
  Eigen::VectorXd robot_init_joint_state_;

  /**
   * @brief Initial transform from robot base to robot end-effector.
   */
  Eigen::Isometry3d init_command_robot_transform_;

  /**
   * @brief Transform from robot world to base.
   */
  Eigen::Isometry3d robot_world_to_base_transform_;

  /**
   * @brief Transform from robot world to end-effector.
   */
  Eigen::Isometry3d robot_world_to_ee_transform_;

  /**
   * @brief Robot base to haptic base transform.
   */
  Eigen::Matrix3d robot_base_to_haptic_base_;

  /**
   * @brief Tool tip to haptic end-effector rotation.
   */
  Eigen::Matrix3d haptic_ee_to_tool_tip_;

  /**
   * @brief Remote center of motion transform with respect to the end-effector frame.
   */
  Eigen::Isometry3d robot_ee_to_TCP_;

  /**
   * @brief Initial transform from haptic base to haptic end-effector.
   */
  Eigen::Isometry3d haptic_device_init_transform_;

  /**
   * @brief Previous robot end-effector transform used for conversion.
   */
  Eigen::Isometry3d robot_previous_transform_;

  /**
   * @brief Initial transform from robot base to end-effector.
   */
  Eigen::Isometry3d robot_base_to_ee_init_transform_;

  /**
   * @brief Actual transformation from the base to the end effector.
   *
   * This transformation represents the current pose of the end effector relative to the base frame.
   */
  Eigen::Isometry3d base_to_end_effector_actual_transform_;

  /**
   * @brief Indicates whether the start transform is set used for convertHapticEEPoseToRobotEEPose_.
   */
  bool is_start_transform_set_;

  /**
   * @brief Scaling factor for position control for each axis.
   */
  Eigen::Vector3d scaling_factor_;

  /**
   * @brief Name of the reference frame of the robot.
   */
  std::string robot_base_frame_;

  /**
   * @brief Name of the end-effector frame of the robot.
   */
  std::string robot_ee_frame_;

  /**
   * @brief Indicates whether the robot is engaged.
   */
  bool robot_engaged_;

  /**
   * @brief Indicates whether the simulation mode is enabled.
   */
  bool simulation_;

  /**
   * @brief Size of the robot state interface.
   */
  size_t robot_state_interface_size_;

  /**
   * @brief Size of the haptic state interface.
   */
  size_t haptic_state_interface_size_;

  /**
   * @brief Indicates whether the haptic device pose topic is ready.
   */
  bool haptic_device_pose_topic_ready_;

  /**
   * @brief Indicates whether the haptic device twist topic is ready.
   */
  bool haptic_device_twist_topic_ready_;

  /**
   * @brief Command pose applied in the update method.
   *
   * This pose represents the command that is applied to the robot in the update method.
   */
  geometry_msgs::msg::Pose haptic_robot_pose_;

  geometry_msgs::msg::Pose last_robot_pose_;

  /**
   * @brief Stamped version of the command pose for logging.
   *
   * This stamped pose is created for logging purposes to include the timestamp and frame information.
   */
  geometry_msgs::msg::PoseStamped haptic_robot_pose_stamped_;

  /**
   * @brief Filter chain for computing the average pose.
   *
   * This filter chain processes multiple channels of double data to compute the average pose.
   * It is initialized with the type "double".
   */
  filters::MultiChannelFilterChain<double> compute_average_pose_filter_chain_ = filters::MultiChannelFilterChain<double>("double");

  /**
   * @brief Input data for the average pose filter chain.
   *
   * This vector holds the input data for the filter chain. Each element in the vector is a double-precision
   * floating-point number representing a data point to be processed by the filter chain.
   */
  std::vector<double> compute_average_pose_input_data_;

  /**
   * @brief Output data from the average pose filter chain.
   *
   * This vector holds the output data from the filter chain. After the input data is processed by the filter chain,
   * the results are stored in this vector.
   */
  std::vector<double> compute_average_pose_output_data_;

  /**
   * @brief Number of channels for the force filter chain.
   *
   * This integer represents the number of channels that the force filter chain will process.
   */
  int number_of_channels_;

  /**
   * @brief Indicates if there is a position command interface.
   *
   * This boolean value is set to true if the controller has a position control interface.
   */
  bool has_position_command_interface_;

  /**
   * @brief Indicates if there is a velocity command interface.
   *
   * This boolean value is set to true if the controller has a velocity control interface.
   */
  bool has_velocity_command_interface_;

  /**
   * @brief Indicates if there is a position state interface.
   *
   * This boolean value is set to true if the controller has a position control interface.
   */
  bool has_position_state_interface_;

  /**
   * @brief Indicates if there is a velocity state interface.
   *
   * This boolean value is set to true if the controller has a velocity control interface.
   */
  bool has_velocity_state_interface_;
};
}  // namespace haptic_ff_controller

#endif  // HAPTIC_FF_CONTROLLER__HAPTIC_FF_CONTROLLER_HPP_
