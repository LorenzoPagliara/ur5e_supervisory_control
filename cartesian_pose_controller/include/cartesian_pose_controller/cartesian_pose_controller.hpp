/* -------------------------------------------------------------------
 *
 * This module has been developed by the Automatic Control Group
 * of the University of Salerno, Italy.
 *
 * Title:   cartesian_pose_controller.hpp
 * Author:  Davide Risi
 * Org.:    UNISA
 * Date:    Apr 7, 2025
 *
 * This module defines a cartesian pose controller.
 *
 * -------------------------------------------------------------------
 */

#pragma once

#include <controller_interface/chainable_controller_interface.hpp>
#include <kinematics_interface/kinematics_interface.hpp>
#include <pluginlib/class_loader.hpp>  // for kinematics_loader_

#include <acg_hardware_interface_facade/state_reader.hpp>
#include <acg_hardware_interface_facade/reference_reader.hpp>
#include <acg_hardware_interface_facade/command_writer.hpp>
#include <acg_control_msgs/msg/task_space_point.hpp>
#include <acg_control_msgs/msg/joint_wrench_point.hpp>
#include <acg_common_libraries/kinematics.hpp>

// auto-generated by generate_parameter_library
#include "cartesian_pose_controller/cartesian_pose_controller_parameters.hpp"

#include "cartesian_pose_controller/visibility_control.h"

namespace cartesian_pose_controller
{

/**
 * @brief Enum defining the states of a controller.
 */
enum State
{
  CONTROL_LAW,
  ERROR_HANDLING,
};

/**
 * @class CartesianPoseController
 * @brief A class representing a cartesian pose controller
 *
 * This class implements the \c controller_interface::ChainableControllerInterface interface.
 * All of the public methods override the corresponding methods of the \c controller_interface::ChainableControllerInterface class.
 * Please refer to the documentation of the base class for more details.
 */
class CartesianPoseController : public controller_interface::ChainableControllerInterface
{
public:
  CARTESIAN_POSE_CONTROLLER_PUBLIC
  CartesianPoseController() = default;

  CARTESIAN_POSE_CONTROLLER_PUBLIC
  ~CartesianPoseController() = default;

  CARTESIAN_POSE_CONTROLLER_PUBLIC
  controller_interface::CallbackReturn on_init() override;

  CARTESIAN_POSE_CONTROLLER_PUBLIC
  controller_interface::CallbackReturn on_configure(const rclcpp_lifecycle::State& previous_state) override;

  CARTESIAN_POSE_CONTROLLER_PUBLIC
  controller_interface::CallbackReturn on_activate(const rclcpp_lifecycle::State& previous_state) override;

  CARTESIAN_POSE_CONTROLLER_PUBLIC
  controller_interface::CallbackReturn on_deactivate(const rclcpp_lifecycle::State& previous_state) override;

  CARTESIAN_POSE_CONTROLLER_PUBLIC
  controller_interface::InterfaceConfiguration command_interface_configuration() const override;

  CARTESIAN_POSE_CONTROLLER_PUBLIC
  controller_interface::InterfaceConfiguration state_interface_configuration() const override;

protected:
  // The following methods are overridden from the base class. Refer to the base class documentation for details.
  std::vector<hardware_interface::CommandInterface> on_export_reference_interfaces() override;
  controller_interface::return_type update_reference_from_subscribers() override;
  bool on_set_chained_mode(bool) override;
  controller_interface::return_type update_and_write_commands(const rclcpp::Time& time, const rclcpp::Duration& period) override;

  /**
   * @brief Computes the control law for the Cartesian pose controller.
   *
   * This function calculates the joint space command (positions or velocities) required to achieve the desired task space reference.
   * It uses forward kinematics to compute the current pose of the robot's end effector, computes the pose error, and calculates the
   * desired joint velocities or positions using the damped least squares inverse Jacobian method.
   * If the desired twist is not provided, the function computes it by numerically derivating the reference pose.
   * The function also clamps the joint space command to the joint limits.
   * The function has the side effect of updating the joint space command.
   *
   * @param[in] period The duration of the control period.
   *
   * @return True if the control law was successfully computed, false otherwise.
   */
  bool compute_control_law_(const rclcpp::Duration& period);

  /**
   * @brief Checks if the current joint space command is within the configured tolerance of the robot current joint state.
   *
   * @return True if all commanded positions and/or velocities are within tolerance, false otherwise.
   */
  bool is_joint_command_within_tolerance_();

  /**
   * @brief Sets the joint space command to a safe state.
   *
   * Sets the commanded joint positions to the last valid command and zeros the commanded velocities.
   * This method is typically called when the controller detects an invalid or unsafe command.
   */
  void set_safe_joint_command_();

  /**
   * @brief Convenience typedef for the Eigen library.
   */
  typedef Eigen::Matrix<double, acg_kinematics::NUM_CARTESIAN_DOF, 1> Vector6d;

  /**
   * @brief Constant to store the duration of the throttle interval as an integral value in milliseconds.
   */
  static const int DURATION_MS_{ 1000 };

  /**
   * @brief Variable to store the current state of the controller.
   */
  State controller_state_{ State::CONTROL_LAW };

  /**
   * @brief Internal variable to store the current joint state of the robot.
   */
  acg_hardware_interface_facade::RobotJointState robot_joint_state_;

  /**
   * @brief Number of joints to control.
   */
  std::size_t num_joints_{ 0 };

  /**
   * @brief Kinematics interface plugin loader.
   */
  std::shared_ptr<pluginlib::ClassLoader<kinematics_interface::KinematicsInterface>> kinematics_loader_;

  /**
   * @brief Pointer to the kinematics interface used for computing forward and inverse kinematics.
   */
  std::shared_ptr<kinematics_interface::KinematicsInterface> kinematics_;

  /**
   * @brief Class for reading the state interfaces.
   */
  acg_hardware_interface_facade::StateReader state_reader_;

  /**
   * @brief Class for writing commands to the robot.
   */
  acg_hardware_interface_facade::CommandWriter command_writer_;

  /**
   * @brief The task space reference frame with respect to which the task space reference is defined.
   */
  std::string task_space_reference_frame_;

  /**
   * @brief Name of the tip link specified in the controller configuration.
   */
  std::string tip_link_;

  /**
   * @brief Shared pointer to the parameter listener responsible for handling the controller's parameters.
   */
  std::shared_ptr<cartesian_pose_controller::ParamListener> parameter_handler_;

  /**
   * @brief Current task space reference received from the previous controller in the chain.
   */
  acg_control_msgs::msg::TaskSpacePoint task_space_reference_;

  /**
   * @brief Last task space reference used in the previous iteration.
   */
  acg_control_msgs::msg::TaskSpacePoint last_reference_;

  /**
   * @brief Current joint space command computed by the controller.
   */
  acg_control_msgs::msg::JointWrenchPoint joint_space_command_;

  /**
   * @brief Last joint space command used in the previous iteration.
   */
  acg_control_msgs::msg::JointWrenchPoint last_command_;

  /**
   * @brief Eigen vector to store joint velocities computed during the control law calculation.
   */
  Eigen::VectorXd eigen_joint_command_velocities_;

  /**
   * @brief Gain matrix used for computing the control law.
   */
  Eigen::Matrix<double, acg_kinematics::NUM_CARTESIAN_DOF, acg_kinematics::NUM_CARTESIAN_DOF> K_matrix_;

  /**
   * @brief Kinematics solver used for robot kinematics calculations.
   */
  acg_kinematics::RTKinematicsSolver robot_kinematics_;

  /**
   * @brief Upper physical limits of the robot joints for positions.
   */
  std::vector<double> joint_positions_upper_limits_;

  /**
   * @brief Lower physical limits of the robot joints for positions.
   */
  std::vector<double> joint_positions_lower_limits_;

  /**
   * @brief Physical limits of the robot joints for velocities.
   */
  std::vector<double> joint_velocity_limits_;

  /**
   * @brief Class for reading the task space reference received as input.
   */
  acg_hardware_interface_facade::ReferenceReader reference_reader_;
};  // class CartesianPoseController

}  // namespace cartesian_pose_controller
