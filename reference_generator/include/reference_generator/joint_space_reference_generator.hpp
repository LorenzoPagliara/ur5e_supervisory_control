/* -------------------------------------------------------------------
 *
 * This module has been developed by the Automatic Control Group
 * of the University of Salerno, Italy.
 *
 * Title:   joint_space_reference_generator.hpp
 * Author:  Davide Risi
 * Org.:    UNISA
 * Date:    Nov 18, 2024
 *
 * This class implements a joint space reference generator based on
 * ros_control.
 *
 * -------------------------------------------------------------------
 */
#pragma once

#include <memory>  // for std::shared_ptr
#include <string>
#include <vector>

#include <rclcpp_action/server.hpp>
#include <realtime_tools/realtime_buffer.hpp>

#include <acg_control_msgs/msg/joint_trajectory.hpp>
#include <acg_control_msgs/action/follow_joint_trajectory.hpp>
#include <acg_control_msgs/msg/joint_wrench_point.hpp>
#include <acg_control_msgs/msg/task_space_point.hpp>
#include <acg_common_libraries/kinematics.hpp>
#include <acg_hardware_interface_facade/command_writer.hpp>

#include "reference_generator/visibility_control.h"
#include "reference_generator/reference_generator.hpp"

// auto-generated by generate_parameter_library
#include "reference_generator/joint_space_reference_generator_parameters.hpp"

namespace joint_space_reference_generator
{

/**
 * @brief Struct that contains the trajectory information of the joint space trajectory.
 *
 * The struct inherits from \c reference_generator::TrajectoryInfo struct.
 * The \p goal_handle_ field is used to store the goal handle of the action server that is executing the trajectory.
 */
struct JointTrajectoryInfo : public reference_generator::TrajectoryInfo
{
  std::shared_ptr<rclcpp_action::ServerGoalHandle<acg_control_msgs::action::FollowJointTrajectory>> goal_handle_{ nullptr };
};

/**
 * @class JointSpaceReferenceGenerator
 * @brief reference generator handling joint space trajectories and online joint space references.
 *
 * This class extends the reference_generator::ReferenceGenerator base class.
 * It manages trajectory execution, including trajectory points, feedback, and the action server for joint space trajectories.
 * In addition, it provides methods for handling trajectory points online via topic.
 * For details on the overridden methods, refer to the documentation of the base class reference_generator::ReferenceGenerator.
 */
class JointSpaceReferenceGenerator : public reference_generator::ReferenceGenerator
{
public:
  REFERENCE_GENERATOR_PUBLIC
  JointSpaceReferenceGenerator();

  REFERENCE_GENERATOR_PUBLIC
  controller_interface::CallbackReturn on_init() override;

  REFERENCE_GENERATOR_PUBLIC
  controller_interface::CallbackReturn on_configure(const rclcpp_lifecycle::State& previous_state) override;

  REFERENCE_GENERATOR_PUBLIC
  controller_interface::CallbackReturn on_activate(const rclcpp_lifecycle::State& previous_state) override;

  REFERENCE_GENERATOR_PUBLIC
  controller_interface::InterfaceConfiguration command_interface_configuration() const override;

protected:
  // Overridden methods from the ReferenceGenerator class
  void abort_trajectory(const std::string& error_string) override;
  void read_references_from_non_rt() override;
  void write_references_to_command_interfaces() override;
  void calculate_and_publish_feedback(const rclcpp::Time& time) override;
  std::size_t get_next_trajectory_index() override;
  bool update_next_reference_from_trajectory() override;
  void handle_trajectory_completed() override;
  void publish_reference_pose(const rclcpp::Time& time) override;
  void read_trajectory_info_from_non_rt() override;

  /**
   * @brief Callback function for handling the joint space trajectory received from the user via a topic
   *
   * Refer to the documentation of the action server for more details about the parameters.
   */
  rclcpp_action::GoalResponse handle_goal_(const rclcpp_action::GoalUUID& uuid,
                                           std::shared_ptr<const acg_control_msgs::action::FollowJointTrajectory::Goal> goal);

  /**
   * @brief Callback function for handling the cancellation of joint space trajectory received from the user via a topic
   *
   * Refer to the documentation of the action server for more details about the parameters.
   */
  rclcpp_action::CancelResponse
  handle_cancel_(const std::shared_ptr<rclcpp_action::ServerGoalHandle<acg_control_msgs::action::FollowJointTrajectory>> goal_handle);

  /**
   * @brief Callback function for handling the acceptance of joint space trajectory received from the user via a topic
   *
   * Refer to the documentation of the action server for more details about the parameters.
   */
  void handle_accepted_(const std::shared_ptr<rclcpp_action::ServerGoalHandle<acg_control_msgs::action::FollowJointTrajectory>> goal_handle);

  /**
   * @brief Callback function for handling the joint space reference received from the user via a topic
   *
   * This function checks the validity of the joint space reference received via topic and stores it in the real-time buffer so that the controller
   * can command it in a real-time loop. In addition, it computes the task space reference via forward kinematics and it publishes it, if desired.
   *
   * @param[in] msg The joint space reference message received from the user
   */
  void joint_space_reference_callback_(const std::shared_ptr<acg_control_msgs::msg::JointWrenchPoint> msg);

  /**
   * @brief Computes the feedback error between the desired and the actual joint space point
   *
   * @param[in] desired The desired joint space point
   * @param[in] actual The actual joint space point
   * @param[out] error The error between the desired and the actual joint space point
   */
  static void compute_feedback_error_(const acg_control_msgs::msg::JointWrenchPoint& desired, const acg_control_msgs::msg::JointWrenchPoint& actual,
                                      acg_control_msgs::msg::JointWrenchPoint& error);

  /**
   * @brief Checks if the joint wrench point point is valid
   *
   * A joint wrench point point is valid if the size of the trajectory point fields is equal to the number of joints of the robot and if the
   * wrench frame exists in the robot description or is empty. This has to be true for all the joint space interface types (i.e. position, velocity,
   * acceleration, effort) specified in the configuration file of the controller. The fields not specified in the configuration file must be empty.
   *
   * @param[in] joint_space_point The joint wrench point point to check
   * @param[in] num_joints The number of joints of the robot
   * @return true if the joint wrench point point is valid, false otherwise
   */
  bool check_joint_space_trajectory_point_(const acg_control_msgs::msg::JointWrenchPoint& joint_space_point, const std::size_t num_joints) const;

  /**
   * @brief Computes the task space point from the joint space point
   *
   * @param[in] positions The joint space positions
   * @param[in] velocities The joint space velocities
   */
  void compute_task_space_point_from_joint_space_(const std::vector<double>& positions, const std::vector<double>& velocities);

  /**
   * @brief Ensures the wrench field of a trajectory point is in the desired frame or cleared if not used.
   *
   * If the the wrench is not used, set all the wrench fields to NaN.
   * If the wrench is different from the desired frame, it transforms the wrench to the desired frame. Note that if the wrench is empty, it is not
   * transformed.
   *
   * @param[in] desired_wrench_frame The desired wrench frame.
   * @param[in] positions The joint positions for the point.
   * @param[in,out] point The trajectory point to update.
   */
  void ensure_wrench_frame_or_clear_(const std::string& desired_wrench_frame, const std::vector<double>& positions,
                                     acg_control_msgs::msg::JointWrenchPoint& point);

  // Pointer to the ParamListener object that handles the parameters for the controller
  std::shared_ptr<joint_space_reference_generator::ParamListener> parameter_handler_;

  // Subscriber for handling the joint space reference received from the user via a topic
  rclcpp::Subscription<acg_control_msgs::msg::JointWrenchPoint>::SharedPtr joint_space_reference_subscriber_;

  // Real-time buffer for the joint space command and the task space command
  realtime_tools::RealtimeBuffer<std::shared_ptr<acg_control_msgs::msg::JointWrenchPoint>> joint_space_reference_buffer_;
  realtime_tools::RealtimeBuffer<std::shared_ptr<acg_control_msgs::msg::TaskSpacePoint>> task_space_reference_buffer_;

  // Action server for handling the joint space trajectory action received from the user
  rclcpp_action::Server<acg_control_msgs::action::FollowJointTrajectory>::SharedPtr joint_space_trajectory_action_server_;

  // Helper classes for reading and writing the command and state interfaces
  acg_hardware_interface_facade::CommandWriter command_writer_;

  // Internal variables to store the joint space reference and the task space reference
  acg_control_msgs::msg::JointWrenchPoint joint_reference_;
  acg_control_msgs::msg::TaskSpacePoint task_space_reference_;

  // Real-time buffer for the trajectory info of the joint space trajectory
  realtime_tools::RealtimeBuffer<JointTrajectoryInfo> trajectory_info_buffer_;

  // Internal variable to handle the trajectory points
  acg_control_msgs::msg::JointTrajectoryPoint current_traj_point_;
  acg_control_msgs::msg::JointTrajectoryPoint next_traj_point_;

  // Trajectory info to store the joint space trajectory information
  JointTrajectoryInfo trajectory_info_;

  // Feedback message for the joint space trajectory action. For real-time safety, the feedback message is pre-allocated in the on_configure method.
  typedef acg_control_msgs::action::FollowJointTrajectory::Feedback JointTrajFeedback;
  std::shared_ptr<JointTrajFeedback> feedback_;

  // Internal variable that handles the computation of the forward kinematics of the robot
  acg_kinematics::RTKinematicsSolver robot_kinematics_;
};

}  // namespace joint_space_reference_generator
