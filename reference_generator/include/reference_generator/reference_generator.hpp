/* -------------------------------------------------------------------
 *
 * This module has been developed by the Automatic Control Group
 * of the University of Salerno, Italy.
 *
 * Title:   reference_generator.hpp
 * Author:  Davide Risi
 * Org.:    UNISA
 * Date:    Feb 4, 2025
 *
 * This module defines an abstract class for reference generators.
 *
 * -------------------------------------------------------------------
 */

#pragma once

#include <controller_interface/controller_interface.hpp>
#include <realtime_tools/realtime_buffer.hpp>
#include <kinematics_interface/kinematics_interface.hpp>
#include <pluginlib/class_loader.hpp>
#include <geometry_msgs/msg/pose_stamped.hpp>

#include <acg_hardware_interface_facade/state_reader.hpp>
#include <acg_common_libraries/diagnostics.hpp>

// auto-generated by generate_parameter_library
#include "reference_generator/reference_generator_parameters.hpp"

#include "reference_generator/visibility_control.h"

namespace reference_generator
{

/**
 * @brief Struct that stores trajectory information for both joint and task space trajectories.
 *
 * This struct holds flags and values related to the trajectory execution, including:
 * - A boolean flag indicating whether a trajectory point has been executed.
 * - The current time, which represents the  elapsed time since trajectory execution began. It starts at 0 and increases by the period of the
 * controller.
 * - The index of the trajectory point currently being executed. If interpolation is used, this refers to the index of the first point in the segment
 * being executed; the second point is at index + 1.
 */
struct TrajectoryInfo
{
  bool first_point_executed_{ false };
  rclcpp::Time current_time_{ 0 };
  std::size_t trajectory_index_{ 0 };
};

/**
 * @brief Enum defining the states of a reference generator controller
 */
enum State
{
  ONLINE_REFERENCE,
  TRAJECTORY_EXECUTION
};

/**
 * @brief Enum defining the events that can be triggered by a reference generator controller
 */
enum Event
{
  NONE,
  TRAJECTORY_COMPLETED,
  TRAJECTORY_CANCELLED,
  TRAJECTORY_ACCEPTED,
  NEW_REFERENCE_PUBLISHED
};

/**
 * @class ReferenceGenerator
 * @brief Abstract class for the reference generators.
 *
 * This class implements the controller_interface::ControllerInterface interface and defines the interface for the reference generators.
 * All of the public methods override the corresponding methods of the \c controller_interface::ControllerInterface class.
 * Please refer to the documentation of the base class for more details.
 */
class ReferenceGenerator : public controller_interface::ControllerInterface
{
public:
  /**
   * @brief Constructor for the ReferenceGenerator class.
   *
   * This constructor initializes the base class of the reference generator with the provided trajectory information,
   * allowing both the base and derived classes to access the same data.
   *
   * @param[in] trajectory_info_base A reference to the base struct that stores trajectory information.
   *
   * @note The \c TrajectoryInfo struct is extended by the derived classes to store class-specific trajectory data.
   * Polymorphism is used to share the trajectory information between the base and derived classes.
   */
  REFERENCE_GENERATOR_PUBLIC
  ReferenceGenerator(TrajectoryInfo& trajectory_info_base);

  REFERENCE_GENERATOR_PUBLIC
  controller_interface::CallbackReturn on_init() override;

  REFERENCE_GENERATOR_PUBLIC
  controller_interface::CallbackReturn on_configure(const rclcpp_lifecycle::State& previous_state) override;

  REFERENCE_GENERATOR_PUBLIC
  controller_interface::CallbackReturn on_activate(const rclcpp_lifecycle::State& previous_state) override;

  REFERENCE_GENERATOR_PUBLIC
  controller_interface::InterfaceConfiguration state_interface_configuration() const override;

  REFERENCE_GENERATOR_PUBLIC
  controller_interface::return_type update(const rclcpp::Time& time, const rclcpp::Duration& period) override;

  REFERENCE_GENERATOR_PUBLIC
  controller_interface::CallbackReturn on_deactivate(const rclcpp_lifecycle::State& previous_state) override;

protected:
  /**
   * @brief Aborts the trajectory execution.
   *
   * @param[in] error_string The error string to be sent to the user.
   */
  virtual void abort_trajectory(const std::string& error_string) = 0;

  /**
   * @brief Updates the reference for the real-time control loop from the latest value set by the non-real-time context.
   *
   * Tranfers data from non-real-time context (written by non real-time methods) to the real-time reference structure in a real-time safe way.
   */
  virtual void read_references_from_non_rt() = 0;

  /**
   * @brief Method to write the references to the command interfaces.
   */
  virtual void write_references_to_command_interfaces() = 0;

  /**
   * @brief Computes and publishes a trajectory feedback message based on the controller's internal logic.
   *
   * This method should handle the logic for generating feedback messages.
   *
   * @param[in] time The current time of the controller.
   */
  virtual void calculate_and_publish_feedback(const rclcpp::Time& time) = 0;

  /**
   * @brief Returns the index of the next trajectory point based on the current time and the trajectory waypoints.
   *
   * @return The next trajectory index to command
   */
  virtual std::size_t get_next_trajectory_index() = 0;

  /**
   * @brief Retrieves the new reference from the trajectory, possibly interpolating between waypoints if necessary.
   *
   * @return true if the operation is successful, false otherwise
   */
  virtual bool update_next_reference_from_trajectory() = 0;

  /**
   * @brief Called when the trajectory execution is complete.
   *
   * This method should handle any logic that needs to occur once the current trajectory has finished executing.
   */
  virtual void handle_trajectory_completed() = 0;

  /**
   * @brief Publishes the task space reference pose so that it can be visualized in RViz, if the controller parameter \p
   * publish_task_space_reference.enable is set to true.
   *
   * @param[in] time The current time of the controller.
   */
  virtual void publish_reference_pose(const rclcpp::Time& time) = 0;

  /**
   * @brief Updates the trajectory information for the real-time control loop from the latest value set by the non-real-time context.
   *
   * Transfers data from non-real-time context (written by non real-time methods) to the real-time trajectory info structure in a real-time safe way.
   */
  virtual void read_trajectory_info_from_non_rt() = 0;

  /**
   * @brief Handles controller logic during trajectory execution.
   *
   * This method is invoked during each control cycle while the controller is executing a trajectory. It is responsible for updating the trajectory
   * information and determining the next reference to command, based on the current time and trajectory waypoints. It may also perform interpolation
   * and manage the trajectory feedback.
   *
   * @param[in] time The current time of the controller.
   * @param[in] period The period of the controller.
   */
  void on_handle_trajectory_execution(const rclcpp::Time& time, const rclcpp::Duration& period);

  /**
   * @brief Non-RT method to trigger the TRAJECTORY_COMPLETED event.
   */
  void trigger_trajectory_completed_event();

  /**
   * @brief Non-RT method to trigger the TRAJECTORY_ACCEPTED event.
   */
  void trigger_trajectory_accepted_event();

  /**
   * @brief Non-RT method to trigger the TRAJECTORY_CANCELLED event.
   */
  void trigger_trajectory_cancelled_event();

  /**
   * @brief Non-RT method to trigger the NEW_REFERENCE_PUBLISHED event.
   */
  void trigger_publish_on_topic_event();

  // Internal variable to store the current joint state of the robot
  acg_hardware_interface_facade::RobotJointState robot_joint_state_;

  // Number of joints to control
  std::size_t num_joints_{ 0 };

  // Kinematics interface plugin loader
  std::shared_ptr<pluginlib::ClassLoader<kinematics_interface::KinematicsInterface>> kinematics_loader_;
  std::shared_ptr<kinematics_interface::KinematicsInterface> kinematics_;

  // Class for reading the state interfaces
  acg_hardware_interface_facade::StateReader state_reader_;

  // Periodic real-time publisher used to visualize the task space reference in RViz
  std::shared_ptr<acg_diagnostics::PeriodicPublisher<geometry_msgs::msg::PoseStamped>> periodic_reference_publisher_;

  // Internal variables to store some parameters of the controller configuration
  std::string task_space_reference_frame_;
  std::string wrench_reference_frame_;
  std::string tip_link_;
  std::string robot_description_;
  std::vector<std::string> state_interfaces_names_;
  bool is_publish_desired_{ true };

protected:
  /**
   * @brief Verifies if the link name is present in the robot description. If not, it logs an error message.
   *
   * @param link_name The name of the link to verify.
   *
   * @return true if the link name is present in the robot description, false otherwise.
   */
  bool verify_link_name_(const std::string& link_name) const;

  // Constant for setting the initial capacity of the strings
  static constexpr short unsigned int STRING_INITIAL_CAPACITY_{ 500 };

  // Attribute to store the publication frequency. It will be overridden by the node parameter.
  double publish_frequency_{ 5.0 };

private:
  // The reference generator class is responsible for handling the FSM of the controller, the events and the parameters of the controller.
  // Therefore, the following attributes are private, as they are intended for this class only.

  // The current internal state of the controller.
  State state_;

  // A thread-safe and real-time safe buffer for events, implemented using realtime_tools::RealtimeBuffer<Event>.
  realtime_tools::RealtimeBuffer<Event> event_buffer_;

  // A shared pointer to the parameter listener, responsible for handling the controller's parameters.
  std::shared_ptr<reference_generator::ParamListener> parameter_handler_;

  // A shared pointer to store the controller's trajectory information.
  std::shared_ptr<TrajectoryInfo> trajectory_info_;

};  // class ReferenceGenerator

}  // namespace reference_generator
